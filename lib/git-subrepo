#!/usr/bin/env bash
#
# Copyright 2013-2015 - Ingy d√∂t Net <ingy@ingy.net>
#

# Exit on any errors:
set -e

# Import Bash+ helper functions:
source "${BASH_SOURCE%/*}/git-subrepo.d/bash+.bash"
bash+:import :std can

VERSION=0.1.0

# `git rev-parse` turns this into a getopt parser and a command usage message:
GETOPT_SPEC="\
git subrepo <command> <arguments> <options>

Commands:
  clone     Clone a remote repository into a local sub-directory
  pull      Pull upstream changes to the subrepo
  push      Push local subrepo changes upstream

  fetch     Fetch a subrepo's remote branch (and create a ref for it)
  branch    Create a branch containing the local subrepo commits
  checkout  Checkout a subrepo branch (creating if necessary)
  commit    Commit a merged subrepo branch into the mainline
  reset     Reset to the branch before a subrepo checkout

  status    Get status of a subrepo (or all of them)
  log       Show log of a subrepo's upstream history
  clean     Remove branches, remotes and grafts for a subrepo

  help      Documentation for git-subrepo (or specfic command)
  version   Display git-subrepo version info

See 'git help subrepo' for complete documentation and usage of each command.

Options:
--
h           Show the command summary
help        Help overview
version     Print the git-subrepo version number

a,all       Perform command on all current subrepos
b,branch=   Specify an upstream branch
F,fetch     Fetch the upstream content first
r,remote=   Specify an upstream remote
s,strategy= Specify a merge strategy
u,update    Add the --branch and/or --remote overrides to .gitrepo

q,quiet     Show minimal output
v,verbose   Show verbose output
x,debug     Turn on -x Bash debugging
"

#------------------------------------------------------------------------------
# Top level function:
#------------------------------------------------------------------------------
main() {
  # Define global variables:
  local command=              # Subrepo subcommand to run
  local command_arguments=()  # Command args after getopt parsing
  local subrepos=()           # List of multiple subrepos
  local quiet_wanted=false    # Output should be quiet
  local verbose_wanted=false  # Output should be verbose
  local all_wanted=false      # Apply command to all subrepos
  local fetch_wanted=false    # Fetch requested for checkout
  local update_wanted=false   # Update .gitrepo with --branch and/or --remote
  local in_subrepo=false      # Subrepo is checked out

  local subdir=               # Subdirectory of the subrepo being used
  local gitrepo=              # Path to .gitrepo file
  local current_branch=       # Branch we were on at start of the command
  local merge_strategy=       # Merge strategy to use
  local in_subrepo_name=      # Name of subrepo that is checked out

  local original_head_commit= # HEAD commit id at start of command
  local original_head_branch= # HEAD ref at start of command
  local upstream_head=        # HEAD commit id from a subrepo fetch
  local update_commit=        # Commit made for clone or pull

  local subrepo_remote=       # Remote url for subrepo's upstream repo
  local subrepo_branch=       # Upstream branch to clone/push/pull
  local subrepo_commit=       # Upstream HEAD from previous clone/pull
  local subrepo_parent=       # Local commit from before previous clone/pull

  local override_remote=      # Remote specified with -r
  local override_branch=      # Remote specified with -b

  local OK=true               # Flag that commands have succeeded
  local FAIL=true             # Flag for RUN: fail on error
  local OUT=false             # Flag for RUN: put output in $output
  local SAY=true              # Flag for RUN: print command for verbose
  local EXEC=false            # Flag for RUN: don't run subprocess

  local git_version=          # Git version in use

  # Check environment and parse CLI options:
  assert-environment-ok

  # Parse and validate command options:
  get-command-options "$@"

  # Make sure repo is in the proper state:
  assert-repo-is-ready

  # Run the command:
  if $all_wanted; then
    local args=( "${command_arguments[@]}" )
    get-all-subrepos
    for subdir in ${subrepos[*]}; do
      subrepo_remote=
      subrepo_branch=
      command_arguments=( "$subdir" "${args[@]}" )
      "command:$command"
    done
  else
    "command:$command"
  fi
}

#------------------------------------------------------------------------------
# API command functions:
#------------------------------------------------------------------------------

# `git subrepo clone <url> [<subdir>]` command:
command:clone() {
  command-setup +subrepo_remote subdir:guess-subdir

  # Fetch the upstream subrepo content to clone:
  subrepo:fetch

  # "clone" the subrepo into the subdir:
  subrepo:clone

  # Successful command output:
  say "Subrepo '$subrepo_remote' ($subrepo_branch) cloned into '$subdir'"
}

# `git subrepo pull <subdir>` command:
# TODO Command needs rewrite:
# * `git subrepo fetch <subdir>`
# * `git subrepo branch <subdir>`
# * `git checkout subrepo/<subdir>`
# * `git merge -s <strategy> refs/subrepo/remote/<subdir>`
# * `git subrepo reset`
# * `git subrepo commit <subdir>`
command:pull() {
  command-setup +subdir

  # Fetch remote content:
  subrepo:fetch

  # Check if we already are up to date:
  if [ "$upstream_head" == "$subrepo_commit" ]; then
    say "Subrepo '$subdir' is up to date"
    return
  fi

  if [ "$merge_strategy" == reclone ]; then
    subrepo:pull-reclone
    say "Subrepo '$subdir' recloned from '$subrepo_remote' ($subrepo_branch)"
    return
  fi

  # Writes best common-ancestor to $subrepo_parent
  get-best-common-ancestor-for-merge

  OUT=true RUN git log --max-count=1 --format=%T "$upstream_head"

  # Create a new commit object from the upstream subrepo HEAD^{tree} with a
  # parent being the best common-ancestor just found:
  OUT=true RUN git commit-tree "$output" -p "$subrepo_parent" \
    -m "$(subrepo:commit-message)"
  update_commit="$output"

  # TODO:
  # This merge can fail, so we need to checkout/merge/remerge instead.

  # Merge the update with the subtree strategy:
  RUN git merge --no-ff \
    -s recursive -X subtree="$subdir" -X patience "$update_commit"

  OK ||
    error "Failed to pull '$subdir'."

  # Now, if our subrepo pull has the same parent as the merge commit (i.e.
  # HEAD^ equals HEAD^2^) then we don't need to clean
  OUT=true RUN git rev-parse HEAD^
  local headparent="$output"
  OUT=true RUN git rev-parse HEAD^2^
  if [ "$headparent" != "$output" ]; then
    # Prune the merge history to keep things looking clean:
    RUN git filter-branch -f \
      --parent-filter "sed 's/ -p $subrepo_parent//'" \
      -- "$update_commit"^..HEAD ^HEAD^

    # The update_commit just got rewritten. Need new id:
    FAIL=false OUT=true RUN git rev-parse HEAD^2
    if ! OK; then
      # This bit helps when there is no second parent- which occurs in certain
      # workflows.
      FAIL=false OUT=true RUN git rev-parse HEAD
    fi
    update_commit="$output"
  fi

  # Update the subdir/.gitrepo file:
  update-gitrepo-file
  RUN git add "$gitrepo"
  RUN git commit --quiet --amend \
    --message="Merge subrepo commit '$(git rev-parse --short "$update_commit")'"

  # Successful command output:
  say "Subrepo '$subdir' pulled from '$subrepo_remote' ($subrepo_branch)"
}

# `git subrepo push <subdir>` command:
# TODO Command needs rewrite:
# * `git subrepo fetch <subdir>`
# * `git subrepo branch <subdir>`
# * `git rebase refs/subrepo/remote/<subdir> subrepo/<subrepo>`
# * `git push <remote> subrepo/<subrepo>`
command:push() {
  command-setup +subdir

  # XXX Probably don't fetch on push.
  subrepo:fetch

  # Checkout the subrepo to a branch:
  subrepo:branch

  local checkout_branch="subrepo/$subdir"
  RUN git checkout "$checkout_branch"

  # Attempt to rebase changes onto upstream:
  FAIL=false RUN git rebase "$upstream_head" "$checkout_branch"

  if ! OK; then
    # Let's rebase a bit more intelligently by using the log to see when the
    # last clone/merge was.  Attempt to rebase A..$checkout_branch onto
    # $upstream_head where A is last clone/merge log entry.
    RUN git rebase --abort #Abort prior failed rebase.
    get-last-subrepo-merge-log-entry
    if [ -n "$output" ]; then
      FAIL=false RUN git rebase \
        --onto "$upstream_head" "$output" "$checkout_branch"
    else
      err "Unable to rebase changes from local branch onto subrepo origin."
      err "Git log entry of previous $subdir clone/merge wasn't found."
      OK=false
    fi
  fi

  if OK; then
    FAIL=false RUN git push \
      "$subrepo_remote" \
      "+$checkout_branch:$subrepo_branch"
  fi

  if ! OK; then
    err "The subrepo push command failed to rebase to upstream."
    err "Try 'git subrepo checkout', and then merge by hand."
    err "See doc for more info: 'git subrepo help'."
    return
  fi

  # Checkout starting branch:
  RUN git checkout "$original_head_branch"

  # Delete the checkout branch:
  #RUN git branch -D "$checkout_branch"

  say "Subrepo '$subdir' pushed to '$subrepo_remote' ($subrepo_branch)"
}

# `git subrepo fetch <subdir>` command
command:fetch() {
  if $in_subrepo; then
    local subdir="$in_subrepo_name"
    command-setup
  else
    command-setup +subdir
  fi
  subrepo:fetch true
}

# `git subrepo branch <subdir>` command:
command:branch() {
  command-setup +subdir
  $fetch_wanted && subrepo:fetch

  local branch="subrepo/$subdir"
  if git:branch-exists "$branch"; then
    error "Branch '$branch' already exists."
  fi

  # Create the subrepo branch:
  subrepo:branch

  say "Created branch 'subrepo/$subdir'"
}

# `git subrepo checkout <subdir>` command:
command:checkout() {
  command-setup +subdir
  $fetch_wanted && subrepo:fetch

  local branch="subrepo/$subdir"
  subrepo:checkout

  say "Switched to branch '$branch'"
}

# `git subrepo commit <subdir>` command
command:commit() {
  error "The 'commit' command not yet implemented."
}

# `git subrepo reset [<branch>]` command
command:reset() {
  $in_subrepo ||
    error "Can't 'subrepo reset'. Subrepo branch not checked out."
  get-params branch:get-mainline-branch
  RUN git checkout "$branch"
  RUN git reset --hard "$branch"
  say "Reset to branch '$branch'"
}

# `git subrepo status [<subdir>]` command:
# TODO just print subdir name if --quiet
command:status() {
  if $in_subrepo; then
    subrepo:status-inside-subrepo
  else
    subrepo:status
  fi
}

# `git subrepo log <subdir>` command
command:log() {
  command-setup +subdir
  $fetch_wanted && subrepo:fetch
  [ -e ".git/refs/subrepo/remote/$subdir" ] ||
    error "No ref 'subrepo/remote/$subdir'. Try fetch first."
  EXEC=true RUN git log "subrepo/remote/$subdir"
}

# `git subrepo clean <subdir>` command
command:clean() {
  command-setup +subdir

  # Remove subrepo branch if exists:
  local ref="refs/heads/subrepo/$subdir"
  if [ -e ".git/$ref" ]; then
    RUN git update-ref -d "$ref"
    say "Removed branch '${ref#refs/heads/}'"
  fi

  local remote="subrepo/$subdir"
  FAIL=false OUT=true RUN git config "remote.$remote.url"
  if [ -n "$output" ]; then
    RUN git remote rm "$remote"
    say "Removed remote '$remote'"
  fi

  # Remove remote ref if exists:
  local ref="refs/subrepo/remote/$subdir"
  if [ -e ".git/$ref" ]; then
    RUN git update-ref -d "$ref"
    say "Removed ref '$ref'"
  fi
}

# Launch the manpage viewer:
command:help() {
  exec git help subrepo
}

# Print version info.
# TODO: Add short commit id after version.
#       Will need to get it from repo or make install can put it somewhere.
command:version() {
  cat <<...
git-subrepo Version: $VERSION
Copyright 2013-2015 Ingy d√∂t Net
https://github.com/git-commands/git-subrepo
$BASH_SOURCE
Git Version: $git_version

...
  :
}

#------------------------------------------------------------------------------
# Subrepo command guts functions:
#------------------------------------------------------------------------------

# Clone by fetching remote content into our subdir:
subrepo:clone() {
  # Make subdir for clone:
  RUN mkdir -p "$subdir"

  # Put remote subrepo content in subdir:
  GIT_WORK_TREE="$subdir" RUN git reset --hard "$upstream_head"

  # Reset index to original commit:
  RUN git reset --mixed "$original_head_commit"

  # Add a new .gitrepo file:
  update-gitrepo-file

  # Add the subdir content to mainline index:
  RUN git add -A "$subdir"

  # Commit this subrepo clone:
  RUN git commit -m "$(subrepo:commit-message)"
}

subrepo:pull-reclone() {
  # Remove the old subdir:
  RUN git rm -r "$subdir"

  # Make the new subdir:
  subrepo:clone
}

# Fetch the subrepo's remote branch content:
subrepo:fetch() {
  local say="${1:-false}"
  # Fetch all the git objects from the subrepo/branch:
  RUN git fetch --quiet "$subrepo_remote" "$subrepo_branch"

  $say && say "Fetched '$subrepo_remote' ($subrepo_branch)"

  # Get the subrepo HEAD commit:
  OUT=true RUN git rev-parse FETCH_HEAD
  upstream_head="$output"

  local output=$(git config "remote.subrepo/$subdir.url")
  if [ -z "$output" ]; then
    RUN git remote add "subrepo/$subdir" "$subrepo_remote"
    $say && say "Created remote 'subrepo/$subdir'"
  else
    if [ "$output" != "$subrepo_remote" ]; then
      git remote set-url "subrepo/$subdir" "$subrepo_remote"
      $say && say "Changed remote 'subrepo/$subdir'"
    fi
  fi

  local ref="refs/subrepo/remote/$subdir"
  OUT=true RUN git for-each-ref "$ref"
  if [ -z "$output" ]; then
    RUN git update-ref "$ref" "$upstream_head"
    $say && say "Created ref '$ref'"
  else
    local commit="$(echo $output | cut -d' ' -f1)"
    if [ "$commit" != "$upstream_head" ]; then
      RUN git update-ref -d "$ref"
      RUN git update-ref "$ref" "$upstream_head"
      $say && say "Changed ref '$ref'"
    fi
  fi

  true    # This is actually needed.
}

# Create a subrepo branch of changes since last push:
subrepo:branch() {
  local branch="subrepo/$subdir"
  git:branch-exists "$branch" && return

  # TODO Actually only filter commits since last push.
  # Make history of subdir changes:
  RUN git filter-branch -f \
    --subdirectory-filter "$subdir" \
    -- HEAD

  # Remove the .gitrepo file from the history:
  RUN git filter-branch -f \
    --tree-filter "rm -f .gitrepo"

  # Create a branch for this checkout:
  RUN git branch "$branch"

#   # Graft subrepo branch to upstream:
#   OUT=true RUN git rev-list --max-parents=0 HEAD
#   local root="$output"
#   echo "$root $subrepo_commit" >> .git/info/grafts

  # Reset to the branch where we started:
  RUN git reset --hard "$original_head_commit"
}

subrepo:checkout() {
  subrepo:branch

  RUN git checkout --quiet "$branch"
}

subrepo:status() {
  if [ ${#command_arguments[@]} -eq 0 ]; then
    get-all-subrepos
    local count=${#subrepos[@]}
    if [ $count -eq 0 ]; then
      echo "Status: No Subrepos."
      exit 1
    else
      local s=
      [ "$count" == 1 ] || s=s
      echo "Status for $count subrepo$s:"
      echo
    fi
  else
    subrepos=("${command_arguments[@]}")
  fi

  for subdir in "${subrepos[@]}"; do
    subdir="${subdir#./}"
    subdir="${subdir%/}"

    if [ ! -f "$subdir/.gitrepo" ]; then
      echo "'$subdir' is not a subrepo"
      echo
      continue
    fi

    subrepo_remote=
    subrepo_branch=
    read-gitrepo-file

    if $quiet_wanted; then
      echo "$subdir"
      return
    fi

    # SubRepo Branch:
    local branch="subrepo/$subdir"
    OUT=true RUN git for-each-ref "refs/heads/$branch"
    local branch_ok="$output"

    cat <<...
Git subrepo '$subdir':
...
    [ -n "$branch_ok" ] && cat <<...
  SubRepo Branch:  $branch
...
    status:remote-name
    cat <<...
  Remote URL:      $subrepo_remote
...
    status:remote-ref
    cat <<...
  Tracking Branch: $subrepo_branch
...
    [ -n "$subrepo_parent" ] && cat <<...
  Pulled Commit:   $(git rev-parse --short $subrepo_parent)
...
    cat <<...
  Previous Pull:   $(git rev-parse --short $subrepo_commit)

...
  done
}

subrepo:status-inside-subrepo() {
  RUN git update-ref \
    "refs/heads/$original_head_branch" \
    "$original_head_commit"
  git:get-mainline-branch-name
  local mainline="$output"
  cat <<...
Subrepo '$in_subrepo_name' branch is currently checked out.

...

  local subdir="$in_subrepo_name"
  status:remote-name
  local got="$output"
  status:remote-ref
  got="$got$output"
  [ -z "$got" ] || echo

  cat <<...
To complete a by-hand "pull" of this subrepo:

  *
  *
  *

To complete a by-hand "push" of this subrepo:

  *
  *
  *

...

[ -z "$mainline" ] || cat <<...
To checkout and reset the '$mainline' branch:

  git subrepo reset

...
}

status:remote-name() {
  # Remote Name:
  local remote="subrepo/$subdir"
  FAIL=false OUT=true RUN git config "remote.$remote.url"

  [ -z "$output" ] || cat <<...
  Remote Name:     subrepo/$subdir
...
}

status:remote-ref() {
  # Remote Ref:
  local ref="refs/subrepo/remote/$subdir"
  OUT=true RUN git for-each-ref "$ref"

  [ -z "$output" ] || cat <<...
  Remote Ref:      $ref
...
}

# Commit msg for an action commit:
subrepo:commit-message() {
  local commit="$(git rev-parse --short "$upstream_head")"
  local args=()
  if $all_wanted; then
    args+=("$subdir")
  fi
  args+=(${command_arguments[@]})

  # Find the specific git-subrepo code used:
  local command_remote='???'
  local command_commit='???'
  get-command-info

  # Format subrepo commit message:
  cat <<...
git subrepo $command ${args[@]}

{"local":
  {"subdir":  "$subdir"
  ,"action":  "$command"}
,"remote":
  {"url":     "$subrepo_remote"
  ,"branch":  "$subrepo_branch"
  ,"commit":  "$commit"}
,"git-subrepo":
  {"version": "$VERSION"
  ,"commit":  "$command_commit"
  ,"origin":  "$command_remote"}}
...
}

#------------------------------------------------------------------------------
# Support functions:
#------------------------------------------------------------------------------

# TODO:
# Collect original options and arguments into an array for commit message
#   They should be normalized and pruned

# Parse command line options:
get-command-options() {
  [ $# -eq 0 ] && set -- --help

  [ -n "$GIT_SUBREPO_DEBUG" ] && set -x
  [ -n "$GIT_SUBREPO_QUIET" ] && quiet_wanted=true
  [ -n "$GIT_SUBREPO_VERBOSE" ] && verbose_wanted=true

  eval "$(
    echo "$GETOPT_SPEC" |
      git rev-parse --parseopt -- "$@" ||
    echo exit $?
  )"

  while [ $# -gt 0 ]; do
    local option="$1"; shift
    case "$option" in
      --) break ;;
      -a) all_wanted=true ;;
      -b) subrepo_branch="$1"
          override_branch="$1"
          shift ;;
      -F) fetch_wanted=true ;;
      -r) subrepo_remote="$1"
          override_remote="$1"
          shift ;;
      -s) merge_strategy="$1"
          shift ;;
      -u) update_wanted=true ;;
      -q) quiet_wanted=true ;;
      -v) verbose_wanted=true ;;
      -x) set -x ;;
      --version)
        echo "$VERSION"
        exit ;;
      *) error "Unexpected option: $option" ;;
    esac
  done

  # Set subrepo command:
  command="$1"; shift

  # Make sure command exists:
  can "command:$command" ||
    error "'$command' is not a command. See 'git subrepo help'."

  command_arguments=("$@")

  if $all_wanted; then
    check_option all
  fi
  if $fetch_wanted; then
    check_option fetch
  fi
  if [ -n "$override_branch" ]; then
    check_option branch
  fi
  if [ -n "$override_remote" ]; then
    check_option remote
  fi
  if $update_wanted; then
    check_option update
    if [ -z "$subrepo_branch" -o -z "$subrepo_remote" ]; then
      error "Can't use '--update' without '--branch' or '--remote'."
    fi
  fi
  if [ -n "$merge_strategy" ]; then
    check_strategy
  fi
}

options_clone='branch'
options_pull='all branch remote strategy update'
options_push='all branch remote strategy update'
options_branch='all'
options_checkout='fetch'
options_fetch='all branch remote'
# options_status='fetch'
options_log='branch fetch remote'
options_clean='all'
check_option() {
  local var="options_$command"
  [[ ${!var} =~ $1 ]] ||
    error "Invalid option '--$1' for '$command'."
}

check_strategy() {
  check_option strategy
  [[ $merge_strategy =~ ^(reclone|rebase|recursive|ours|theirs)$ ]] ||
    error "Invalid merge strategy: '$merge_strategy'."
}

#------------------------------------------------------------------------------
# Command argument validation:
#------------------------------------------------------------------------------

# Do the setup steps needed by most of the subrepo subcommands:
command-setup() {
  get-params "$@"

  # Sanity check subdir:
  [ -n "$subdir" ] ||
    die "subdir not set"
  [[ "$subdir" =~ ^/ ]] &&
    error "The subdir '$subdir' should not be absolute path."
  subdir="${subdir#./}"
  subdir="${subdir%/}"

  # Read/parse the .gitrepo file (unless clone; doesn't exist yet)
  gitrepo="$subdir/.gitrepo"
  if [ "$command" == "clone" ]; then
    assert-subdir-empty
    get-upstream-head-branch
    subrepo_branch="${subrepo_branch:-$output}"
  else
    read-gitrepo-file
    # $in_subrepo || read-gitrepo-file
    # subrepo_remote="subrepo/$subdir"
  fi

  :
}

# Parse command line args according to a simple dsl spec:
get-params() {
  local i=0
  local num=${#command_arguments[@]}
  for arg in $@; do
    # If arg starts with '+' then it is required
    if [[ "$arg" =~ ^\+ ]]; then
      if [ $i -ge $num ]; then
        error "Command '$command' requires arg '${arg#+}'."
      fi
      printf -v ${arg#+} "${command_arguments[i]}"
    # Look for function name after ':' to provide a default value
    elif [[ "$arg" =~ : ]]; then
      if [ $i -lt $num ]; then
        printf -v ${arg%:*} "${command_arguments[i]}"
      else
        "${arg#*:}"
      fi
    fi
    let i=$((i+1))
  done

  # Check for extra arguments:
  if [ $num -gt $i ]; then
    set -- ${command_arguments[@]}
    for ((j = 1; j <= i; j++)); do shift; done
    error "Unknown argument(s) '$*' for '$command' command."
  fi
}

# Determine the correct subdir path to use:
guess-subdir() {
  local dir="$subrepo_remote"
  dir="${dir%.git}"
  dir="${dir%/}"
  dir="${dir##*/}"
  [[ "$dir" =~ ^[-a-zA-Z0-9]+$ ]] ||
    error "Can't determine subdir from '$subrepo_remote'."
  subdir="$dir"
}

#------------------------------------------------------------------------------
# State file (`.gitrepo`) functions:
#------------------------------------------------------------------------------

# Set subdir and gitrepo vars:
read-gitrepo-file() {
  gitrepo="$subdir/.gitrepo"

  if [ ! -f "$gitrepo" ]; then
    error "'$subdir' is not a subrepo."
  fi

  # Read .gitrepo values:
  if [ -z "$subrepo_remote" ]; then
    SAY=false OUT=true RUN git config --file="$gitrepo" subrepo.remote
    subrepo_remote="$output"
  fi

  if [ -z "$subrepo_branch" ]; then
    SAY=false OUT=true RUN git config --file="$gitrepo" subrepo.branch
    subrepo_branch="$output"
  fi

  SAY=false OUT=true RUN git config --file="$gitrepo" subrepo.commit
  subrepo_commit="$output"

  # XXX FAIL=false is a hack for missing 'former'
  SAY=false FAIL=false OUT=true RUN git config \
    --file="$gitrepo" subrepo.parent
  subrepo_parent="$output"
}

# Update the subdir/.gitrepo state file:
update-gitrepo-file() {
  local short_commit=

  local newfile=false
  [ ! -e "$gitrepo" ] &&
    newfile=true

  $newfile && cat <<... > "$gitrepo"
; DO NOT EDIT (unless you know what you are doing)
;
; This subdirectory is a git "subrepo", and this file is maintained by the
; git-subrepo command. See https://github.com/git-commands/git-subrepo#readme
;
...

  # TODO: only update remote and branch if supplied and $update_wanted
  if $newfile || [ $update_wanted -a -n "$override_remote" ]; then
    RUN git config --file="$gitrepo" subrepo.remote "$subrepo_remote"
  fi

  if $newfile || [ $update_wanted -a -n "$override_branch" ]; then
    RUN git config --file="$gitrepo" subrepo.branch "$subrepo_branch"
  fi

  RUN git config --file="$gitrepo" subrepo.commit "$upstream_head"
  RUN git config --file="$gitrepo" subrepo.parent "$original_head_commit"
  RUN git config --file="$gitrepo" subrepo.cmdver "$VERSION"
}

#------------------------------------------------------------------------------
# Enviroment checks:
#------------------------------------------------------------------------------

# Check that system is ok for this command:
assert-environment-ok() {
  type git &> /dev/null ||
    error "Can't find your 'git' command in '$PATH'."
  git_version="$(git --version)"
  if [[ "$git_version" < "git version 1.7" ]]; then
    error "Requires git version 1.7 or higher; you have '$git_version'."
  fi
}

# Make sure git repo is ready:
assert-repo-is-ready() {
  # Skip this for trivial info commands:
  [[ "$command" =~ ^(help|version)$ ]] && return

  # We must be inside a git repo:
  git rev-parse --git-dir &> /dev/null ||
    error "Not inside a git repository."

  # Get the original branch and commit:
  git:get-head-branch-name
  original_head_branch="$output"
  git:get-head-branch-commit
  original_head_commit="$output"

  # If a subrepo branch is currently checked out, then note it:
  if [[ "$original_head_branch" =~ ^subrepo/(.*) ]]; then
    in_subrepo=true
    in_subrepo_name="${BASH_REMATCH[1]}"
  # Else save this branch as the 'mainline' for the 'reset' command:
  else
    git:get-mainline-branch-name
    if [ "$output" != "$original_head_branch" ]; then
      RUN git symbolic-ref \
        "SUBREPO_ORIG_HEAD" \
        "refs/heads/$original_head_branch"
    fi
  fi

  if $in_subrepo; then
    if [[ ! "$command" =~ ^(fetch|commit|reset|status|log)$ ]]; then
      error "Can't '$command' while subrepo branch is checked out."
    fi
    if [ ${#command_arguments[@]} -gt 0 ] && [ "$command" != reset ]; then
      error "Arguments to '$command' are invalid while subrepo checked out."
    fi
  fi

  # Make sure we are on a branch:
  [ "$original_head_branch" == HEAD -o -z "$original_head_branch" ] &&
    error "Must be on a branch to run this command."

  # In a work-tree:
  SAY=false OUT=true RUN git rev-parse --is-inside-work-tree
  [ "$output" == true ] ||
    error "Can't 'subrepo $command' outside a working tree."

  # HEAD exists:
  RUN git rev-parse --verify HEAD

  # Repo is in a clean state:
  if [[ "$command" =~ ^(clone|pull|push|checkout)$ ]]; then
    git update-index -q --ignore-submodules --refresh
    git diff-files --quiet --ignore-submodules ||
      error "Can't $command subrepo. Unstaged changes."
    git diff-index --quiet --ignore-submodules HEAD ||
      error "Can't $command subrepo. Working tree has changes."
    git diff-index --quiet --cached --ignore-submodules HEAD ||
      error "Can't $command subrepo. Index has changes."
  fi

  # For now, only support actions from top of repo:
  if [ "$(git rev-parse --git-dir)" != '.git' ]; then
    error "Need to run subrepo command from top level directory of the repo."
  fi
}

# If subdir exists, make sure it is empty:
assert-subdir-empty() {
  if [ -e "$subdir" ] && [ -n "$(ls -A $subdir)" ]; then
    error "The subdir '$subdir' exists and is not empty."
  fi
}

#------------------------------------------------------------------------------
# Getters of various information:
#------------------------------------------------------------------------------

get-all-subrepos() {
  local paths=($(
    find . -name '.gitrepo' |
      grep -v '/.git/' |
      grep '/.gitrepo$' |
      sed 's/.gitrepo$//' |
      sort
  ))
  subrepos=()
  local path
  for path in "${paths[@]}"; do
    add-subrepo "$path"
  done
}

add-subrepo() {
  for path in "${subrepos[@]}"; do
    [[ "$1" =~ ^$path ]] && return
  done
  subrepos+=("$1")
}

get-mainline-branch() {
  git:get-mainline-branch-name
  [ -n "$output" ] ||
    error "Can't determine mainline branch."
  branch="$output"
}

# Determine the upstream's default head branch:
get-upstream-head-branch() {
  OUT=true RUN git ls-remote $subrepo_remote
  local remotes="$output"
  [ -n "$remotes" ] ||
    error "Failed to 'git ls-remote $subrepo_remote'."
  local commit="$(
    echo "$remotes" |
    grep HEAD |
    cut -f1
  )"
  local branch="$(
    echo "$remotes" |
    grep "$commit" |
    grep -v HEAD |
    head -n1 |
    cut -f2
  )"
  [[ "$branch" =~ refs/heads/ ]] ||
    error "Problem finding remote default head branch."
  output="${branch#refs/heads/}"
}

get-command-info() {
  local bin="$0"
  if [[ "$bin" =~ / ]]; then
    local lib="$(dirname "$bin")"
    # XXX Makefile needs to install these symlinks:
    # If `git-subrepo` was system-installed (`make install`):
    if [ -e "$lib/git-subrepo.d/remote" ] &&
       [ -e "$lib/git-subrepo.d/commit" ]; then
      command_remote=$(readlink "$lib/git-subrepo.d/remote")
      command_commit=$(readlink "$lib/git-subrepo.d/commit")
    elif [[ "$lib" =~ / ]]; then
      lib="$(dirname "$lib")"
      if [ -d "$lib/.git" ]; then
        local remote="$(
          GIT_DIR=$lib/.git git remote -v |
            grep '^origin' |
            head -n1 |
            cut -f2 |
            cut -d ' ' -f1
        )"
        if [ -n "$remote" ]; then
          command_remote="$remote"
        else
          local remote="$(
            GIT_DIR=$lib/.git git remote -v |
              head -n1 |
              cut -f2 |
              cut -d ' ' -f1
          )"
          if [ -n "$remote" ]; then
            command_remote="$remote"
          fi
        fi
        local commit="$(GIT_DIR="$lib/.git" git rev-parse --short HEAD)"
        if [ -n "$commit" ]; then
          command_commit="$commit"
        fi
      fi
    fi
  fi
}

# Writes best common-ancestor to $subrepo_parent
get-best-common-ancestor-for-merge() {
  # Writes to $subrepo_parent if relevant clone/pull subrepo log entry found;
  # writes latest match. Note log doesn't contain last subrepo push.
  get-last-original-head-branch-subrepo-log-hash

  # Now, if there were no commits since the above we know we have the best
  # common-ancestor:
  OUT=true RUN git rev-parse "$original_head_branch"
  if [ "$output" = "$subrepo_parent" ]; then
    return
  fi

  # Need to know when to terminate outer loop, must get tree object of above
  # relevant clone/pull commit object for the subrepo directory without the
  # .gitrepo file included:
  local outer_loop_term_tree=
  # RUN doesn't support piping completely, must do this process substition to
  # get output of mktree
  OUT=true RUN git mktree < \
    <(git ls-tree "$subrepo_parent:$subdir" | sed -r '/^.*\.gitrepo.*$/d')
  if [ -z $output ]; then
    err "Failed to obtain tree-id of $subdir in relevant clone/pull commit object without .gitrepo file."
    return
  fi
  outer_loop_term_tree="$output"

  # These are the outer loop elements, the tree of each commit in the subrepo
  # branch:
  OUT=true RUN sed '/commit/d' < \
    <(git rev-list subrepo/remote/$subdir --format="format:%T")
  local outer_loop_elems="$output"

  # These are the inner loop elements, cached here so they're only looked up
  # once.
  OUT=true RUN git rev-list \
    "$subrepo_parent".."$original_head_branch" -- "$subdir"
  local inner_loop_elems="$output"

  # Outer loop we search subrepo/$suddir branch A..HEAD^{tree} where A was
  # found above ($outer_loop_term_tree).  Start at subrepo/$subdir branch and
  # traverse to A as long as match (subrepo push) is not found.
  # KLUDGE: Note I have a bit of uncertainty about this iteration. Might be a
  # good spot for a new test case.
  for o in $outer_loop_elems; do
    if [ "$o" = "$outer_loop_term_tree" ]; then
       # No need to continue. We know $subrepo_parent is best common-ancestor.
       break
    fi

    # Inner loop we search $original_head_branch branch B..HEAD where B is
    # $subrepo_parent found earlier.
    for i in $inner_loop_elems; do
      OUT=true RUN git mktree < \
        <(git ls-tree "$i:$subdir" | sed -r '/^.*\.gitrepo.*$/d')
      if [ -z "$output" ]; then
        err "Failed to obtain tree-id of $subdir in $i without .gitrepo file."
        continue
      fi
      if [ "$output" = "$o" ]; then
        # We have discovered that the subrepo had been pushed to from
        # $original_head_branch since the last clone/pull. We know that $i is
        # the best common ancestor!
        subrepo_parent="$i"
        return
      fi
    done
  done
}

# Writes to $subrepo_parent if relevant subrepo log entry found; writes latest
# match.
get-last-original-head-branch-subrepo-log-hash() {
  # First try the log for pull/clone entries. Note no push entries are
  # possible in the log, so we must search for that later as it would be the
  # best common-ancestor candidate as git won't automatically select it during
  # the merge.
  FAIL=false OUT=true RUN git log \
    --grep="git subrepo pull $subdir" -n 1 --pretty="format:%H"
  if [ -z "$output" ]; then
    # TODO: "subrepo clone.*$subdir" should better match what is written by
    # subrepo:commit-message()"
    FAIL=false OUT=true RUN git log \
      --grep="subrepo clone.*$subdir" -n 1 --pretty="format:%H"
  fi
  if [ -n "$output" ]; then
    subrepo_parent="$output" # AKA common-ancestor for merge to be done soon.
  else
    err "Failed to obtain last subrepo log entry."
  fi
}

get-last-subrepo-merge-log-entry() {
  # Get last subrepo merge commit to the local branch for $subdir
  # TODO: This would match subrepos in $subdir as well! Need to resolve.
  FAIL=false OUT=true RUN git log \
    --grep="Merge subrepo commit" -n 1 --pretty="format:%H"
  if [ -z "$output" ]; then
    # The user hadn't pushed/pulled $subdir before, so they must have only
    # cloned.
    # TODO: "subrepo clone.*$subdir" should better match what is written by
    # subrepo:commit-message()"
    FAIL=false OUT=true RUN git log \
      --grep="subrepo clone.*$subdir" -n 1 --pretty="format:%H"
  fi
}

#------------------------------------------------------------------------------
# Git command wrappers:
#------------------------------------------------------------------------------

git:branch-exists() {
  local branch="$1"
  git show-ref --verify --quiet "refs/heads/$branch"
}

git:get-head-branch-name() {
  output=
  local name="$(git rev-parse --abbrev-ref HEAD)"
  [ "$name" == HEAD ] && return
  output="$name"
}

git:get-head-branch-commit() {
  output="$(git rev-parse HEAD)"
}

git:get-mainline-branch-name() {
  output=
  local name="$(git rev-parse --abbrev-ref SUBREPO_ORIG_HEAD 2>/dev/null)"
  [ "$name" == SUBREPO_ORIG_HEAD ] && return
  output="$name"
}

#------------------------------------------------------------------------------
# Low level sugar commands:
#------------------------------------------------------------------------------

# Smart command runner:
RUN() {
  $verbose_wanted && $SAY && say '>>>' $*
  if $EXEC; then
    "$@"
    return $?
  fi

  OK=true
  set +e
  local rc=
  local out=
  if $verbose_wanted; then
    out="$("$@")"
  else
    if $OUT; then
      out="$("$@" 2>/dev/null)"
    else
      out="$("$@" 2>&1)"
    fi
  fi
  rc=$?
  set -e

  if [ "$rc" -ne 0 ]; then
    OK=false
    $FAIL && error "Command failed: '$*'."
  fi
  if $OUT; then
    output="$out"
  fi
}

# Print unless quiet mode:
say() {
  $quiet_wanted || echo "$@"
}

# Print to stderr:
err() {
  echo "$@" >&2
}

# Check if OK:
OK() {
  $OK
}

# Nicely report common error messages:
error() {
  local msg=
  printf -v msg "git-subrepo: %s\n" "$1"
  die "$msg"
}

# Start at the end:
[ "$BASH_SOURCE" != "$0" ] || main "$@"

# vim: set ft=sh sw=2 lisp:
